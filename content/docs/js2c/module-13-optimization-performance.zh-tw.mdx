# 模組 13: 效能優化和最佳實踐

## 概述

在本模組中，我們將探索 C 程式設計中的進階效能優化技術和最佳實踐。與 JavaScript 不同，JavaScript 的優化通常由 JIT 編譯器處理，而 C 語言讓你可以直接控制機器層級的效能。

## 學習目標

- 理解編譯器優化選項及其效果
- 掌握內聯函數及其效能優勢
- 學習快取友好程式碼設計原則
- 實作演算法優化技術
- 應用記憶體優化策略
- 有效使用效能分析工具

## 編譯器優化選項

### JavaScript vs C 優化

在 JavaScript 中，優化主要由 V8 引擎的 JIT 編譯器處理。在 C 中，你可以透過編譯器標誌和程式碼結構直接控制優化。

<UniversalEditor title="編譯器優化對比" compare={true}>
```javascript !! js
// JavaScript: V8 自動處理優化
function fibonacci(n) {
    if (n <= 1) return n;
    return fibonacci(n - 1) + fibonacci(n - 2);
}

// V8 會自動優化這個函數
const result = fibonacci(10);
console.log(result);
```

```c !! c
// C: 手動優化控制
#include <stdio.h>

// 無優化版本
int fibonacci_unoptimized(int n) {
    if (n <= 1) return n;
    return fibonacci_unoptimized(n - 1) + fibonacci_unoptimized(n - 2);
}

// 內聯優化版本
static inline int fibonacci_optimized(int n) {
    if (n <= 1) return n;
    return fibonacci_optimized(n - 1) + fibonacci_optimized(n - 2);
}

int main() {
    // 編譯命令: gcc -O2 -o program program.c
    int result = fibonacci_optimized(10);
    printf("Fibonacci(10) = %d\n", result);
    return 0;
}
```
</UniversalEditor>

### 常用編譯器標誌

<UniversalEditor title="編譯器優化標誌" compare={true}>
```javascript !! js
// JavaScript: Node.js 優化標誌
// node --max-old-space-size=4096 --optimize-for-size script.js

function processLargeArray(arr) {
    return arr.map(x => x * 2).filter(x => x > 10);
}

const largeArray = Array.from({length: 1000000}, (_, i) => i);
const result = processLargeArray(largeArray);
console.log(result.length);
```

```c !! c
// C: GCC 優化標誌
#include <stdio.h>
#include <stdlib.h>

// 使用不同優化級別編譯:
// gcc -O0 -o program program.c    (無優化)
// gcc -O1 -o program program.c    (基本優化)
// gcc -O2 -o program program.c    (更多優化)
// gcc -O3 -o program program.c    (激進優化)
// gcc -Os -o program program.c    (優化大小)

void process_large_array(int* arr, int size, int* result, int* result_size) {
    int count = 0;
    for (int i = 0; i < size; i++) {
        int doubled = arr[i] * 2;
        if (doubled > 10) {
            result[count++] = doubled;
        }
    }
    *result_size = count;
}

int main() {
    const int size = 1000000;
    int* arr = malloc(size * sizeof(int));
    int* result = malloc(size * sizeof(int));
    int result_size;
    
    // 初始化陣列
    for (int i = 0; i < size; i++) {
        arr[i] = i;
    }
    
    process_large_array(arr, size, result, &result_size);
    printf("處理了 %d 個元素\n", result_size);
    
    free(arr);
    free(result);
    return 0;
}
```
</UniversalEditor>

## 內聯函數

### JavaScript vs C 內聯函數

JavaScript 引擎自動內聯函數，而 C 需要顯式的內聯宣告。

<UniversalEditor title="內聯函數對比" compare={true}>
```javascript !! js
// JavaScript: V8 自動內聯小函數
function add(a, b) {
    return a + b;
}

function multiply(a, b) {
    return a * b;
}

// 這些呼叫很可能被 V8 內聯
let sum = 0;
for (let i = 0; i < 1000000; i++) {
    sum += add(i, 1);
    sum += multiply(i, 2);
}
console.log(sum);
```

```c !! c
// C: 顯式內聯函數
#include <stdio.h>

// 內聯函數宣告
static inline int add(int a, int b) {
    return a + b;
}

static inline int multiply(int a, int b) {
    return a * b;
}

int main() {
    int sum = 0;
    
    // 這些函數呼叫將被編譯器內聯
    for (int i = 0; i < 1000000; i++) {
        sum += add(i, 1);
        sum += multiply(i, 2);
    }
    
    printf("總和: %d\n", sum);
    return 0;
}
```
</UniversalEditor>

### 內聯函數最佳實踐

<UniversalEditor title="內聯函數最佳實踐" compare={true}>
```javascript !! js
// JavaScript: 小函數自動優化
function calculateDistance(x1, y1, x2, y2) {
    const dx = x2 - x1;
    const dy = y2 - y1;
    return Math.sqrt(dx * dx + dy * dy);
}

// 在緊密迴圈中使用 - V8 會優化
function processPoints(points) {
    let totalDistance = 0;
    for (let i = 0; i < points.length - 1; i++) {
        totalDistance += calculateDistance(
            points[i].x, points[i].y,
            points[i + 1].x, points[i + 1].y
        );
    }
    return totalDistance;
}
```

```c !! c
// C: 對效能關鍵函數使用顯式內聯
#include <stdio.h>
#include <math.h>

// 小的、頻繁呼叫的函數適合內聯
static inline double calculate_distance(double x1, double y1, 
                                       double x2, double y2) {
    double dx = x2 - x1;
    double dy = y2 - y1;
    return sqrt(dx * dx + dy * dy);
}

// 避免對大函數使用內聯
static inline void process_large_data(int* data, int size) {
    // 這個函數太大不適合內聯 - 編譯器可能忽略內聯提示
    for (int i = 0; i < size; i++) {
        // 複雜處理...
        data[i] = data[i] * 2 + 1;
    }
}

int main() {
    double points[][2] = {{1.0, 1.0}, {2.0, 2.0}, {3.0, 3.0}};
    int num_points = 3;
    
    double total_distance = 0.0;
    for (int i = 0; i < num_points - 1; i++) {
        total_distance += calculate_distance(
            points[i][0], points[i][1],
            points[i + 1][0], points[i + 1][1]
        );
    }
    
    printf("總距離: %.2f\n", total_distance);
    return 0;
}
```
</UniversalEditor>

## 快取友好程式碼設計

### 記憶體存取模式

<UniversalEditor title="快取友好陣列存取" compare={true}>
```javascript !! js
// JavaScript: 陣列存取通常是快取友好的
function processMatrix(matrix) {
    const rows = matrix.length;
    const cols = matrix[0].length;
    let sum = 0;
    
    // 列優先存取（在大多數語言中都是快取友好的）
    for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
            sum += matrix[i][j];
        }
    }
    
    return sum;
}

const matrix = Array.from({length: 1000}, () => 
    Array.from({length: 1000}, (_, i) => i)
);
console.log(processMatrix(matrix));
```

```c !! c
// C: 顯式快取友好設計
#include <stdio.h>
#include <stdlib.h>

#define ROWS 1000
#define COLS 1000

// 快取友好: 列優先存取
int process_matrix_row_major(int matrix[ROWS][COLS]) {
    int sum = 0;
    
    // 按列優先順序存取元素（快取友好）
    for (int i = 0; i < ROWS; i++) {
        for (int j = 0; j < COLS; j++) {
            sum += matrix[i][j];
        }
    }
    
    return sum;
}

// 快取不友好: 行優先存取
int process_matrix_column_major(int matrix[ROWS][COLS]) {
    int sum = 0;
    
    // 按行優先順序存取元素（快取不友好）
    for (int j = 0; j < COLS; j++) {
        for (int i = 0; i < ROWS; i++) {
            sum += matrix[i][j];
        }
    }
    
    return sum;
}

int main() {
    int (*matrix)[COLS] = malloc(ROWS * sizeof(*matrix));
    
    // 初始化矩陣
    for (int i = 0; i < ROWS; i++) {
        for (int j = 0; j < COLS; j++) {
            matrix[i][j] = i + j;
        }
    }
    
    int sum1 = process_matrix_row_major(matrix);
    int sum2 = process_matrix_column_major(matrix);
    
    printf("列優先總和: %d\n", sum1);
    printf("行優先總和: %d\n", sum2);
    
    free(matrix);
    return 0;
}
```
</UniversalEditor>

### 資料結構優化

<UniversalEditor title="資料結構快取優化" compare={true}>
```javascript !! js
// JavaScript: 物件和陣列由引擎優化
class Particle {
    constructor(x, y, vx, vy, mass) {
        this.x = x;
        this.y = y;
        this.vx = vx;
        this.vy = vy;
        this.mass = mass;
    }
}

// 物件陣列 - V8 優化存取模式
function updateParticles(particles) {
    for (let particle of particles) {
        particle.x += particle.vx;
        particle.y += particle.vy;
    }
}

const particles = Array.from({length: 1000}, () => 
    new Particle(Math.random(), Math.random(), 1, 1, 1)
);
updateParticles(particles);
```

```c !! c
// C: 陣列結構 (SoA) 以獲得更好的快取效能
#include <stdio.h>
#include <stdlib.h>

// 結構陣列 (AoS) - 快取友好性較差
typedef struct {
    double x, y, vx, vy, mass;
} Particle_AoS;

// 陣列結構 (SoA) - 更快取友好
typedef struct {
    double* x;
    double* y;
    double* vx;
    double* vy;
    double* mass;
    int count;
} Particle_SoA;

void update_particles_aos(Particle_AoS* particles, int count) {
    for (int i = 0; i < count; i++) {
        particles[i].x += particles[i].vx;
        particles[i].y += particles[i].vy;
    }
}

void update_particles_soa(Particle_SoA* particles) {
    for (int i = 0; i < particles->count; i++) {
        particles->x[i] += particles->vx[i];
        particles->y[i] += particles->vy[i];
    }
}

int main() {
    const int count = 1000;
    
    // AoS 方法
    Particle_AoS* particles_aos = malloc(count * sizeof(Particle_AoS));
    for (int i = 0; i < count; i++) {
        particles_aos[i].x = (double)rand() / RAND_MAX;
        particles_aos[i].y = (double)rand() / RAND_MAX;
        particles_aos[i].vx = 1.0;
        particles_aos[i].vy = 1.0;
        particles_aos[i].mass = 1.0;
    }
    
    // SoA 方法
    Particle_SoA particles_soa = {
        .x = malloc(count * sizeof(double)),
        .y = malloc(count * sizeof(double)),
        .vx = malloc(count * sizeof(double)),
        .vy = malloc(count * sizeof(double)),
        .mass = malloc(count * sizeof(double)),
        .count = count
    };
    
    for (int i = 0; i < count; i++) {
        particles_soa.x[i] = (double)rand() / RAND_MAX;
        particles_soa.y[i] = (double)rand() / RAND_MAX;
        particles_soa.vx[i] = 1.0;
        particles_soa.vy[i] = 1.0;
        particles_soa.mass[i] = 1.0;
    }
    
    update_particles_aos(particles_aos, count);
    update_particles_soa(&particles_soa);
    
    // 清理
    free(particles_aos);
    free(particles_soa.x);
    free(particles_soa.y);
    free(particles_soa.vx);
    free(particles_soa.vy);
    free(particles_soa.mass);
    
    return 0;
}
```
</UniversalEditor>

## 演算法優化

### 迴圈優化

<UniversalEditor title="迴圈優化技術" compare={true}>
```javascript !! js
// JavaScript: 迴圈優化
function sumArray(arr) {
    let sum = 0;
    const len = arr.length; // 快取長度
    
    // 展開迴圈以獲得更好效能
    for (let i = 0; i < len; i += 4) {
        if (i < len) sum += arr[i];
        if (i + 1 < len) sum += arr[i + 1];
        if (i + 2 < len) sum += arr[i + 2];
        if (i + 3 < len) sum += arr[i + 3];
    }
    
    return sum;
}

const array = Array.from({length: 1000000}, (_, i) => i);
console.log(sumArray(array));
```

```c !! c
// C: 進階迴圈優化
#include <stdio.h>
#include <stdlib.h>

// 迴圈展開以獲得更好效能
int sum_array_unrolled(int* arr, int size) {
    int sum = 0;
    int i;
    
    // 按 4 展開迴圈
    for (i = 0; i < size - 3; i += 4) {
        sum += arr[i] + arr[i + 1] + arr[i + 2] + arr[i + 3];
    }
    
    // 處理剩餘元素
    for (; i < size; i++) {
        sum += arr[i];
    }
    
    return sum;
}

// 向量化友好迴圈
int sum_array_vectorized(int* arr, int size) {
    int sum = 0;
    
    // 編譯器可以向量化的簡單迴圈
    for (int i = 0; i < size; i++) {
        sum += arr[i];
    }
    
    return sum;
}

int main() {
    const int size = 1000000;
    int* arr = malloc(size * sizeof(int));
    
    for (int i = 0; i < size; i++) {
        arr[i] = i;
    }
    
    int sum1 = sum_array_unrolled(arr, size);
    int sum2 = sum_array_vectorized(arr, size);
    
    printf("展開迴圈總和: %d\n", sum1);
    printf("向量化總和: %d\n", sum2);
    
    free(arr);
    return 0;
}
```
</UniversalEditor>

### 演算法複雜度優化

<UniversalEditor title="演算法複雜度優化" compare={true}>
```javascript !! js
// JavaScript: 演算法優化
function findDuplicates(arr) {
    const seen = new Set();
    const duplicates = new Set();
    
    for (const item of arr) {
        if (seen.has(item)) {
            duplicates.add(item);
        } else {
            seen.add(item);
        }
    }
    
    return Array.from(duplicates);
}

// O(n) 解決方案而不是 O(n²)
const numbers = [1, 2, 3, 4, 2, 5, 6, 3, 7, 8, 1];
console.log(findDuplicates(numbers));
```

```c !! c
// C: 使用雜湊表的演算法優化
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_SIZE 1000
#define HASH_SIZE 10007

// 簡單雜湊函數
unsigned int hash(int key) {
    return key % HASH_SIZE;
}

// 使用雜湊表查找重複項 - O(n) 而不是 O(n²)
int* find_duplicates(int* arr, int size, int* result_size) {
    int* hash_table = calloc(HASH_SIZE, sizeof(int));
    int* result = malloc(size * sizeof(int));
    *result_size = 0;
    
    for (int i = 0; i < size; i++) {
        unsigned int h = hash(arr[i]);
        
        if (hash_table[h] == 0) {
            hash_table[h] = 1;
        } else if (hash_table[h] == 1) {
            // 找到重複項
            result[*result_size] = arr[i];
            (*result_size)++;
            hash_table[h] = 2; // 標記為已新增
        }
    }
    
    free(hash_table);
    return result;
}

int main() {
    int arr[] = {1, 2, 3, 4, 2, 5, 6, 3, 7, 8, 1};
    int size = sizeof(arr) / sizeof(arr[0]);
    
    int result_size;
    int* duplicates = find_duplicates(arr, size, &result_size);
    
    printf("重複項: ");
    for (int i = 0; i < result_size; i++) {
        printf("%d ", duplicates[i]);
    }
    printf("\n");
    
    free(duplicates);
    return 0;
}
```
</UniversalEditor>

## 記憶體優化策略

### 記憶體池實作

<UniversalEditor title="記憶體池優化" compare={true}>
```javascript !! js
// JavaScript: 記憶體管理由 V8 處理
class MemoryPool {
    constructor(blockSize, poolSize) {
        this.blockSize = blockSize;
        this.poolSize = poolSize;
        this.pool = new ArrayBuffer(poolSize);
        this.freeBlocks = [];
        
        // 預分配塊
        for (let i = 0; i < poolSize; i += blockSize) {
            this.freeBlocks.push(i);
        }
    }
    
    allocate() {
        if (this.freeBlocks.length === 0) {
            throw new Error('池已耗盡');
        }
        return this.freeBlocks.pop();
    }
    
    free(offset) {
        this.freeBlocks.push(offset);
    }
}

const pool = new MemoryPool(64, 1024);
const block1 = pool.allocate();
const block2 = pool.allocate();
pool.free(block1);
```

```c !! c
// C: 用於效能的自訂記憶體池
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define BLOCK_SIZE 64
#define POOL_SIZE 1024
#define MAX_BLOCKS (POOL_SIZE / BLOCK_SIZE)

typedef struct {
    char pool[POOL_SIZE];
    int free_blocks[MAX_BLOCKS];
    int free_count;
    int used_blocks[MAX_BLOCKS];
    int used_count;
} MemoryPool;

MemoryPool* create_memory_pool() {
    MemoryPool* pool = malloc(sizeof(MemoryPool));
    memset(pool->pool, 0, POOL_SIZE);
    
    // 初始化空閒塊
    pool->free_count = MAX_BLOCKS;
    for (int i = 0; i < MAX_BLOCKS; i++) {
        pool->free_blocks[i] = i;
    }
    
    pool->used_count = 0;
    return pool;
}

void* pool_allocate(MemoryPool* pool) {
    if (pool->free_count == 0) {
        return NULL; // 池已耗盡
    }
    
    int block_index = pool->free_blocks[--pool->free_count];
    pool->used_blocks[pool->used_count++] = block_index;
    
    return &pool->pool[block_index * BLOCK_SIZE];
}

void pool_free(MemoryPool* pool, void* ptr) {
    char* char_ptr = (char*)ptr;
    int offset = char_ptr - pool->pool;
    int block_index = offset / BLOCK_SIZE;
    
    // 新增回空閒列表
    pool->free_blocks[pool->free_count++] = block_index;
    
    // 從已使用列表中移除
    for (int i = 0; i < pool->used_count; i++) {
        if (pool->used_blocks[i] == block_index) {
            pool->used_blocks[i] = pool->used_blocks[--pool->used_count];
            break;
        }
    }
}

void destroy_memory_pool(MemoryPool* pool) {
    free(pool);
}

int main() {
    MemoryPool* pool = create_memory_pool();
    
    // 分配塊
    void* block1 = pool_allocate(pool);
    void* block2 = pool_allocate(pool);
    
    if (block1 && block2) {
        strcpy((char*)block1, "Hello");
        strcpy((char*)block2, "World");
        
        printf("塊1: %s\n", (char*)block1);
        printf("塊2: %s\n", (char*)block2);
        
        pool_free(pool, block1);
        pool_free(pool, block2);
    }
    
    destroy_memory_pool(pool);
    return 0;
}
```
</UniversalEditor>

## 效能分析工具

### 效能分析和基準測試

<UniversalEditor title="效能分析工具" compare={true}>
```javascript !! js
// JavaScript: 效能測量
function measurePerformance(fn, iterations = 1000000) {
    const start = performance.now();
    
    for (let i = 0; i < iterations; i++) {
        fn();
    }
    
    const end = performance.now();
    return end - start;
}

function optimizedFunction() {
    let sum = 0;
    for (let i = 0; i < 1000; i++) {
        sum += i;
    }
    return sum;
}

function unoptimizedFunction() {
    let sum = 0;
    for (let i = 0; i < 1000; i++) {
        sum = sum + i; // 優化較少
    }
    return sum;
}

const time1 = measurePerformance(optimizedFunction);
const time2 = measurePerformance(unoptimizedFunction);

console.log(`優化版本: ${time1.toFixed(2)}ms`);
console.log(`未優化版本: ${time2.toFixed(2)}ms`);
```

```c !! c
// C: 效能測量和分析
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <sys/time.h>

// 高精度計時器
double get_time() {
    struct timeval tv;
    gettimeofday(&tv, NULL);
    return tv.tv_sec + tv.tv_usec * 1e-6;
}

// 效能測量函數
double measure_performance(int (*func)(), int iterations) {
    double start_time = get_time();
    
    for (int i = 0; i < iterations; i++) {
        func();
    }
    
    double end_time = get_time();
    return (end_time - start_time) * 1000.0; // 轉換為毫秒
}

// 優化函數
int optimized_function() {
    int sum = 0;
    for (int i = 0; i < 1000; i++) {
        sum += i;
    }
    return sum;
}

// 未優化函數
int unoptimized_function() {
    int sum = 0;
    for (int i = 0; i < 1000; i++) {
        sum = sum + i; // 優化較少
    }
    return sum;
}

int main() {
    const int iterations = 1000000;
    
    double time1 = measure_performance(optimized_function, iterations);
    double time2 = measure_performance(unoptimized_function, iterations);
    
    printf("優化版本: %.2f ms\n", time1);
    printf("未優化版本: %.2f ms\n", time2);
    printf("加速比: %.2fx\n", time2 / time1);
    
    return 0;
}
```
</UniversalEditor>

## 常見陷阱和解決方案

### 效能反模式

<UniversalEditor title="效能反模式" compare={true}>
```javascript !! js
// JavaScript: 效能反模式
function inefficientStringConcatenation() {
    let result = '';
    for (let i = 0; i < 10000; i++) {
        result += 'x'; // 每次都建立新字串
    }
    return result;
}

function efficientStringConcatenation() {
    const parts = [];
    for (let i = 0; i < 10000; i++) {
        parts.push('x');
    }
    return parts.join(''); // 單次連接
}

// 測量差異
const start1 = performance.now();
inefficientStringConcatenation();
const end1 = performance.now();

const start2 = performance.now();
efficientStringConcatenation();
const end2 = performance.now();

console.log(`低效版本: ${(end1 - start1).toFixed(2)}ms`);
console.log(`高效版本: ${(end2 - start2).toFixed(2)}ms`);
```

```c !! c
// C: 效能反模式和解決方案
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

// 低效: 重複呼叫 strlen
int inefficient_string_processing(char* str) {
    int count = 0;
    for (int i = 0; i < strlen(str); i++) { // 每次迭代都呼叫 strlen
        if (str[i] == 'a') count++;
    }
    return count;
}

// 高效: 快取 strlen 結果
int efficient_string_processing(char* str) {
    int count = 0;
    int len = strlen(str); // 只呼叫一次
    for (int i = 0; i < len; i++) {
        if (str[i] == 'a') count++;
    }
    return count;
}

// 低效: 迴圈中不必要的函數呼叫
int inefficient_loop() {
    int sum = 0;
    for (int i = 0; i < 1000000; i++) {
        sum += rand() % 100; // 迴圈中的函數呼叫
    }
    return sum;
}

// 高效: 快取函數結果
int efficient_loop() {
    int sum = 0;
    for (int i = 0; i < 1000000; i++) {
        // 使用快取值或內聯計算
        sum += i % 100;
    }
    return sum;
}

int main() {
    char test_string[] = "這是一個包含許多字元的測試字串";
    
    clock_t start, end;
    double cpu_time_used;
    
    // 測試字串處理
    start = clock();
    for (int i = 0; i < 100000; i++) {
        inefficient_string_processing(test_string);
    }
    end = clock();
    cpu_time_used = ((double)(end - start)) / CLOCKS_PER_SEC;
    printf("低效字串處理: %.3f 秒\n", cpu_time_used);
    
    start = clock();
    for (int i = 0; i < 100000; i++) {
        efficient_string_processing(test_string);
    }
    end = clock();
    cpu_time_used = ((double)(end - start)) / CLOCKS_PER_SEC;
    printf("高效字串處理: %.3f 秒\n", cpu_time_used);
    
    return 0;
}
```
</UniversalEditor>

## 練習題

### 練習 1: 迴圈優化
優化以下 C 函數以獲得更好效能：

```c
int sum_array_slow(int* arr, int size) {
    int sum = 0;
    for (int i = 0; i < size; i++) {
        sum = sum + arr[i];
    }
    return sum;
}
```

### 練習 2: 記憶體存取模式
重寫以下函數使其更快取友好：

```c
void process_matrix_slow(int matrix[1000][1000]) {
    for (int j = 0; j < 1000; j++) {
        for (int i = 0; i < 1000; i++) {
            matrix[i][j] *= 2;
        }
    }
}
```

### 練習 3: 演算法優化
將這個 O(n²) 演算法優化為 O(n log n) 或更好：

```c
int find_max_difference(int* arr, int size) {
    int max_diff = 0;
    for (int i = 0; i < size; i++) {
        for (int j = i + 1; j < size; j++) {
            int diff = abs(arr[i] - arr[j]);
            if (diff > max_diff) {
                max_diff = diff;
            }
        }
    }
    return max_diff;
}
```

## 效能分析總結

### 關鍵優化技術

1. **編譯器優化**: 使用適當的編譯器標誌 (-O2, -O3)
2. **內聯函數**: 對小的、頻繁呼叫的函數使用 `static inline`
3. **快取友好設計**: 按順序模式存取記憶體
4. **迴圈優化**: 展開迴圈並避免在迴圈中呼叫函數
5. **記憶體管理**: 對頻繁分配使用記憶體池
6. **演算法選擇**: 為你的用例選擇合適的演算法

### 效能測量

- 使用 `clock()` 或 `gettimeofday()` 進行計時
- 使用 `gprof` 或 `perf` 等工具進行分析
- 測量時間和記憶體使用
- 使用真實資料大小進行測試
- 考慮快取效果和記憶體存取模式

### 最佳實踐

- 在優化前進行分析
- 專注於最關鍵的程式碼路徑
- 使用適當的資料結構
- 避免過早優化
- 使用真實資料測試優化
- 記錄效能特徵

## 下一步

在下一個模組中，我們將探索進階主題，包括：
- 多執行緒和並行
- 進階記憶體管理技術
- SIMD 優化
- 平台特定優化
- 即時程式設計考慮

本模組為你提供了優化 C 程式碼的基本工具和技術。記住，最好的優化通常是為你的特定用例選擇正確的演算法和資料結構。 