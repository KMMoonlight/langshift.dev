# Module 15: Swift Style Guide

## Overview

This module covers Swift-specific idioms, best practices, and coding conventions that will help you write more Swift-like and efficient code. Understanding these patterns will make your Swift code more readable, maintainable, and performant.

## Learning Objectives

- Learn Swift-specific idioms and patterns
- Understand Swift coding conventions and style guidelines
- Master Swift best practices for performance and readability
- Apply Swift-specific design patterns
- Write idiomatic Swift code

---

## 15.1 Swift Naming Conventions

### 15.1.1 Variable and Function Names

**JavaScript Style**
```javascript
// JavaScript uses camelCase
const userName = "John";
const userAge = 25;
const isActive = true;

function getUserData() { }
function processUserInput() { }
```

**Swift Style**
```swift
// Swift uses camelCase but with different conventions
let userName = "John"
let userAge = 25
let isActive = true

func getUserData() { }
func processUserInput() { }

// Swift prefers descriptive names
let numberOfItems = 10 // not numItems
let maximumValue = 100 // not maxVal
```

### 15.1.2 Type Names

**JavaScript**
```javascript
// JavaScript uses PascalCase for classes
class UserProfile { }
class DataProcessor { }
```

**Swift**
```swift
// Swift uses PascalCase for types
struct UserProfile { }
class DataProcessor { }
enum NetworkError { }
protocol DataSource { }
```

---

## 15.2 Swift Idioms

### 15.2.1 Optional Binding

**JavaScript (Null Checking)**
```javascript
function processUser(user) {
    if (user && user.name) {
        console.log(user.name);
        return user.name.length;
    }
    return 0;
}
```

**Swift (Optional Binding)**
```swift
func processUser(_ user: User?) -> Int {
    guard let user = user, let name = user.name else {
        return 0
    }
    print(name)
    return name.count
}

// Alternative with if let
func processUser(_ user: User?) -> Int {
    if let user = user, let name = user.name {
        print(name)
        return name.count
    }
    return 0
}
```

### 15.2.2 Collection Operations

**JavaScript**
```javascript
const numbers = [1, 2, 3, 4, 5];
const doubled = numbers.map(x => x * 2);
const filtered = numbers.filter(x => x > 2);
const sum = numbers.reduce((acc, x) => acc + x, 0);
```

**Swift**
```swift
let numbers = [1, 2, 3, 4, 5]
let doubled = numbers.map { $0 * 2 }
let filtered = numbers.filter { $0 > 2 }
let sum = numbers.reduce(0, +)

// Swift-specific: compactMap for optionals
let optionalNumbers = ["1", "2", "abc", "3"]
let validNumbers = optionalNumbers.compactMap { Int($0) }
```

---

## 15.3 Swift-Specific Patterns

### 15.3.1 Property Observers

**JavaScript (Getters/Setters)**
```javascript
class User {
    constructor() {
        this._name = '';
    }
    
    get name() {
        return this._name;
    }
    
    set name(value) {
        this._name = value;
        this.updateDisplay();
    }
}
```

**Swift (Property Observers)**
```swift
class User {
    var name: String = "" {
        didSet {
            updateDisplay()
        }
        willSet {
            print("Changing name from \(name) to \(newValue)")
        }
    }
}
```

### 15.3.2 Computed Properties

**JavaScript**
```javascript
class Rectangle {
    constructor(width, height) {
        this.width = width;
        this.height = height;
    }
    
    get area() {
        return this.width * this.height;
    }
}
```

**Swift**
```swift
struct Rectangle {
    let width: Double
    let height: Double
    
    var area: Double {
        return width * height
    }
    
    // Read-only computed property
    var isSquare: Bool {
        return width == height
    }
}
```

---

## 15.4 Error Handling Patterns

### 15.4.1 Custom Error Types

**JavaScript**
```javascript
class ValidationError extends Error {
    constructor(message, field) {
        super(message);
        this.name = 'ValidationError';
        this.field = field;
    }
}
```

**Swift**
```swift
enum ValidationError: Error {
    case invalidEmail(String)
    case invalidAge(Int)
    case missingField(String)
    
    var localizedDescription: String {
        switch self {
        case .invalidEmail(let email):
            return "Invalid email format: \(email)"
        case .invalidAge(let age):
            return "Age must be positive, got: \(age)"
        case .missingField(let field):
            return "Missing required field: \(field)"
        }
    }
}
```

### 15.4.2 Result Type

**JavaScript (Promise-based)**
```javascript
async function fetchUser(id) {
    try {
        const response = await fetch(`/api/users/${id}`);
        if (!response.ok) {
            throw new Error('User not found');
        }
        return await response.json();
    } catch (error) {
        throw error;
    }
}
```

**Swift (Result Type)**
```swift
func fetchUser(id: Int) async -> Result<User, NetworkError> {
    do {
        let url = URL(string: "https://api.example.com/users/\(id)")!
        let (data, response) = try await URLSession.shared.data(from: url)
        
        guard let httpResponse = response as? HTTPURLResponse,
              httpResponse.statusCode == 200 else {
            return .failure(.invalidResponse)
        }
        
        let user = try JSONDecoder().decode(User.self, from: data)
        return .success(user)
    } catch {
        return .failure(.networkError(error))
    }
}
```

---

## 15.5 Performance Best Practices

### 15.5.1 Value Types vs Reference Types

**Swift (Prefer Structs)**
```swift
// ✅ Good: Use structs for simple data
struct Point {
    var x: Double
    var y: Double
}

// ✅ Good: Use classes for complex behavior
class DataManager {
    private var cache: [String: Any] = [:]
    
    func getData(for key: String) -> Any? {
        return cache[key]
    }
}
```

### 15.5.2 Lazy Properties

**Swift**
```swift
class ExpensiveObject {
    lazy var expensiveComputation: String = {
        // This is only computed when first accessed
        return performExpensiveOperation()
    }()
    
    private func performExpensiveOperation() -> String {
        // Simulate expensive operation
        return "Computed result"
    }
}
```

---

## 15.6 Swift-Specific Features

### 15.6.1 Extensions

**Swift**
```swift
// Extend existing types
extension String {
    var isEmail: Bool {
        let emailRegex = "[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,64}"
        return NSPredicate(format: "SELF MATCHES %@", emailRegex).evaluate(with: self)
    }
    
    func truncated(to length: Int) -> String {
        return count > length ? String(prefix(length)) + "..." : self
    }
}

// Use extensions for protocol conformance
extension User: Equatable {
    static func == (lhs: User, rhs: User) -> Bool {
        return lhs.id == rhs.id
    }
}
```

### 15.6.2 Generics with Constraints

**Swift**
```swift
// Generic function with constraints
func findMax<T: Comparable>(_ items: [T]) -> T? {
    return items.max()
}

// Generic type with multiple constraints
struct Cache<Key: Hashable, Value> {
    private var storage: [Key: Value] = [:]
    
    mutating func set(_ value: Value, for key: Key) {
        storage[key] = value
    }
    
    func get(_ key: Key) -> Value? {
        return storage[key]
    }
}
```

---

## 15.7 Code Organization

### 15.7.1 File Structure

**Swift File Organization**
```swift
// 1. Imports
import Foundation
import UIKit

// 2. Protocol definitions
protocol DataSource {
    func fetchData() async throws -> [String]
}

// 3. Main type definition
class DataManager: DataSource {
    // MARK: - Properties
    private let cache = NSCache<NSString, NSArray>()
    
    // MARK: - Initialization
    init() {
        setupCache()
    }
    
    // MARK: - Public Methods
    func fetchData() async throws -> [String] {
        // Implementation
        return []
    }
    
    // MARK: - Private Methods
    private func setupCache() {
        cache.countLimit = 100
    }
}
```

### 15.7.2 Access Control

**Swift**
```swift
public class PublicAPI {
    public init() { }
    
    public func publicMethod() { }
    
    internal func internalMethod() { }
    
    private func privateMethod() { }
}

// File-private access
fileprivate struct InternalHelper {
    func helperMethod() { }
}
```

---

## 15.8 Documentation

### 15.8.1 Swift Documentation Comments

**Swift**
```swift
/// A user in the system
struct User {
    /// The unique identifier for the user
    let id: UUID
    
    /// The user's display name
    var name: String
    
    /// The user's email address
    var email: String
    
    /// Creates a new user with the specified information
    /// - Parameters:
    ///   - name: The user's display name
    ///   - email: The user's email address
    /// - Returns: A new User instance
    init(name: String, email: String) {
        self.id = UUID()
        self.name = name
        self.email = email
    }
    
    /// Validates the user's email address
    /// - Returns: `true` if the email is valid, `false` otherwise
    func validateEmail() -> Bool {
        return email.contains("@")
    }
}
```

---

## 15.9 Exercises

### Exercise 1: Swift Idioms
Convert this JavaScript code to use Swift idioms:

```javascript
function processUsers(users) {
    const validUsers = users.filter(user => user && user.name);
    const names = validUsers.map(user => user.name);
    const uniqueNames = [...new Set(names)];
    return uniqueNames.sort();
}
```

### Exercise 2: Error Handling
Create a Swift function that demonstrates proper error handling:

```swift
// Create a function that reads a file and parses JSON
// Use proper error types and Result type
```

### Exercise 3: Property Observers
Create a Swift class that uses property observers to validate data:

```swift
// Create a User class with property observers
// Validate email format when email is set
// Log changes to name property
```

---

## 15.10 Key Takeaways

- **Naming**: Use descriptive names and follow Swift conventions
- **Optionals**: Always handle optionals safely and use optional binding
- **Value Types**: Prefer structs over classes when possible
- **Extensions**: Use extensions to organize code and add functionality
- **Error Handling**: Use Swift's error handling system properly
- **Documentation**: Document your code using Swift documentation comments
- **Performance**: Use lazy properties and value types for better performance

---

## 15.11 Swift Style Checklist

- [ ] Use camelCase for variables and functions
- [ ] Use PascalCase for types
- [ ] Handle optionals safely
- [ ] Use guard statements for early returns
- [ ] Prefer structs over classes when possible
- [ ] Use extensions to organize code
- [ ] Document public APIs
- [ ] Use appropriate access control
- [ ] Follow Swift naming conventions
- [ ] Use Swift-specific features appropriately

---

Congratulations! You have completed the JavaScript to Swift learning path. You now have a solid foundation in Swift development and understand the key differences and similarities between JavaScript and Swift. 