# 模块 15：Swift 风格指南

## 概述

本模块涵盖 Swift 特定的惯用法、最佳实践和编码约定，帮助你编写更符合 Swift 风格且高效的代码。理解这些模式将使你的 Swift 代码更易读、更易维护且性能更优。

## 学习目标

- 学习 Swift 特定的惯用法和模式
- 理解 Swift 编码约定和风格指南
- 掌握 Swift 性能和可读性的最佳实践
- 应用 Swift 特定的设计模式
- 编写符合 Swift 风格的代码

---

## 15.1 Swift 命名约定

### 15.1.1 变量和函数命名

**JavaScript 风格**
```javascript
// JavaScript 使用 camelCase
const userName = "John";
const userAge = 25;
const isActive = true;

function getUserData() { }
function processUserInput() { }
```

**Swift 风格**
```swift
// Swift 使用 camelCase 但有不同的约定
let userName = "John"
let userAge = 25
let isActive = true

func getUserData() { }
func processUserInput() { }

// Swift 偏好描述性名称
let numberOfItems = 10 // 不是 numItems
let maximumValue = 100 // 不是 maxVal
```

### 15.1.2 类型命名

**JavaScript**
```javascript
// JavaScript 使用 PascalCase 命名类
class UserProfile { }
class DataProcessor { }
```

**Swift**
```swift
// Swift 使用 PascalCase 命名类型
struct UserProfile { }
class DataProcessor { }
enum NetworkError { }
protocol DataSource { }
```

---

## 15.2 Swift 惯用法

### 15.2.1 可选绑定

**JavaScript（空值检查）**
```javascript
function processUser(user) {
    if (user && user.name) {
        console.log(user.name);
        return user.name.length;
    }
    return 0;
}
```

**Swift（可选绑定）**
```swift
func processUser(_ user: User?) -> Int {
    guard let user = user, let name = user.name else {
        return 0
    }
    print(name)
    return name.count
}

// 使用 if let 的替代方案
func processUser(_ user: User?) -> Int {
    if let user = user, let name = user.name {
        print(name)
        return name.count
    }
    return 0
}
```

### 15.2.2 集合操作

**JavaScript**
```javascript
const numbers = [1, 2, 3, 4, 5];
const doubled = numbers.map(x => x * 2);
const filtered = numbers.filter(x => x > 2);
const sum = numbers.reduce((acc, x) => acc + x, 0);
```

**Swift**
```swift
let numbers = [1, 2, 3, 4, 5]
let doubled = numbers.map { $0 * 2 }
let filtered = numbers.filter { $0 > 2 }
let sum = numbers.reduce(0, +)

// Swift 特有：compactMap 处理可选类型
let optionalNumbers = ["1", "2", "abc", "3"]
let validNumbers = optionalNumbers.compactMap { Int($0) }
```

---

## 15.3 Swift 特定模式

### 15.3.1 属性观察器

**JavaScript（Getters/Setters）**
```javascript
class User {
    constructor() {
        this._name = '';
    }
    
    get name() {
        return this._name;
    }
    
    set name(value) {
        this._name = value;
        this.updateDisplay();
    }
}
```

**Swift（属性观察器）**
```swift
class User {
    var name: String = "" {
        didSet {
            updateDisplay()
        }
        willSet {
            print("正在将名称从 \(name) 更改为 \(newValue)")
        }
    }
}
```

### 15.3.2 计算属性

**JavaScript**
```javascript
class Rectangle {
    constructor(width, height) {
        this.width = width;
        this.height = height;
    }
    
    get area() {
        return this.width * this.height;
    }
}
```

**Swift**
```swift
struct Rectangle {
    let width: Double
    let height: Double
    
    var area: Double {
        return width * height
    }
    
    // 只读计算属性
    var isSquare: Bool {
        return width == height
    }
}
```

---

## 15.4 错误处理模式

### 15.4.1 自定义错误类型

**JavaScript**
```javascript
class ValidationError extends Error {
    constructor(message, field) {
        super(message);
        this.name = 'ValidationError';
        this.field = field;
    }
}
```

**Swift**
```swift
enum ValidationError: Error {
    case invalidEmail(String)
    case invalidAge(Int)
    case missingField(String)
    
    var localizedDescription: String {
        switch self {
        case .invalidEmail(let email):
            return "邮箱格式无效: \(email)"
        case .invalidAge(let age):
            return "年龄必须为正数，得到: \(age)"
        case .missingField(let field):
            return "缺少必需字段: \(field)"
        }
    }
}
```

### 15.4.2 Result 类型

**JavaScript（基于 Promise）**
```javascript
async function fetchUser(id) {
    try {
        const response = await fetch(`/api/users/${id}`);
        if (!response.ok) {
            throw new Error('User not found');
        }
        return await response.json();
    } catch (error) {
        throw error;
    }
}
```

**Swift（Result 类型）**
```swift
func fetchUser(id: Int) async -> Result<User, NetworkError> {
    do {
        let url = URL(string: "https://api.example.com/users/\(id)")!
        let (data, response) = try await URLSession.shared.data(from: url)
        
        guard let httpResponse = response as? HTTPURLResponse,
              httpResponse.statusCode == 200 else {
            return .failure(.invalidResponse)
        }
        
        let user = try JSONDecoder().decode(User.self, from: data)
        return .success(user)
    } catch {
        return .failure(.networkError(error))
    }
}
```

---

## 15.5 性能最佳实践

### 15.5.1 值类型 vs 引用类型

**Swift（优先使用结构体）**
```swift
// ✅ 好：对简单数据使用结构体
struct Point {
    var x: Double
    var y: Double
}

// ✅ 好：对复杂行为使用类
class DataManager {
    private var cache: [String: Any] = [:]
    
    func getData(for key: String) -> Any? {
        return cache[key]
    }
}
```

### 15.5.2 懒加载属性

**Swift**
```swift
class ExpensiveObject {
    lazy var expensiveComputation: String = {
        // 只在首次访问时计算
        return performExpensiveOperation()
    }()
    
    private func performExpensiveOperation() -> String {
        // 模拟昂贵操作
        return "计算结果"
    }
}
```

---

## 15.6 Swift 特定功能

### 15.6.1 扩展

**Swift**
```swift
// 扩展现有类型
extension String {
    var isEmail: Bool {
        let emailRegex = "[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,64}"
        return NSPredicate(format: "SELF MATCHES %@", emailRegex).evaluate(with: self)
    }
    
    func truncated(to length: Int) -> String {
        return count > length ? String(prefix(length)) + "..." : self
    }
}

// 使用扩展实现协议
extension User: Equatable {
    static func == (lhs: User, rhs: User) -> Bool {
        return lhs.id == rhs.id
    }
}
```

### 15.6.2 带约束的泛型

**Swift**
```swift
// 带约束的泛型函数
func findMax<T: Comparable>(_ items: [T]) -> T? {
    return items.max()
}

// 带多个约束的泛型类型
struct Cache<Key: Hashable, Value> {
    private var storage: [Key: Value] = [:]
    
    mutating func set(_ value: Value, for key: Key) {
        storage[key] = value
    }
    
    func get(_ key: Key) -> Value? {
        return storage[key]
    }
}
```

---

## 15.7 代码组织

### 15.7.1 文件结构

**Swift 文件组织**
```swift
// 1. 导入
import Foundation
import UIKit

// 2. 协议定义
protocol DataSource {
    func fetchData() async throws -> [String]
}

// 3. 主类型定义
class DataManager: DataSource {
    // MARK: - 属性
    private let cache = NSCache<NSString, NSArray>()
    
    // MARK: - 初始化
    init() {
        setupCache()
    }
    
    // MARK: - 公共方法
    func fetchData() async throws -> [String] {
        // 实现
        return []
    }
    
    // MARK: - 私有方法
    private func setupCache() {
        cache.countLimit = 100
    }
}
```

### 15.7.2 访问控制

**Swift**
```swift
public class PublicAPI {
    public init() { }
    
    public func publicMethod() { }
    
    internal func internalMethod() { }
    
    private func privateMethod() { }
}

// 文件私有访问
fileprivate struct InternalHelper {
    func helperMethod() { }
}
```

---

## 15.8 文档

### 15.8.1 Swift 文档注释

**Swift**
```swift
/// 系统中的用户
struct User {
    /// 用户的唯一标识符
    let id: UUID
    
    /// 用户的显示名称
    var name: String
    
    /// 用户的邮箱地址
    var email: String
    
    /// 使用指定信息创建新用户
    /// - Parameters:
    ///   - name: 用户的显示名称
    ///   - email: 用户的邮箱地址
    /// - Returns: 新的 User 实例
    init(name: String, email: String) {
        self.id = UUID()
        self.name = name
        self.email = email
    }
    
    /// 验证用户的邮箱地址
    /// - Returns: 如果邮箱有效返回 `true`，否则返回 `false`
    func validateEmail() -> Bool {
        return email.contains("@")
    }
}
```

---

## 15.9 练习

### 练习 1：Swift 惯用法
将这个 JavaScript 代码转换为使用 Swift 惯用法：

```javascript
function processUsers(users) {
    const validUsers = users.filter(user => user && user.name);
    const names = validUsers.map(user => user.name);
    const uniqueNames = [...new Set(names)];
    return uniqueNames.sort();
}
```

### 练习 2：错误处理
创建一个演示正确错误处理的 Swift 函数：

```swift
// 创建一个读取文件并解析 JSON 的函数
// 使用正确的错误类型和 Result 类型
```

### 练习 3：属性观察器
创建一个使用属性观察器验证数据的 Swift 类：

```swift
// 创建一个带有属性观察器的 User 类
// 设置邮箱时验证邮箱格式
// 记录名称属性的更改
```

---

## 15.10 关键要点

- **命名**：使用描述性名称并遵循 Swift 约定
- **可选类型**：始终安全处理可选类型并使用可选绑定
- **值类型**：尽可能优先使用结构体而不是类
- **扩展**：使用扩展组织代码并添加功能
- **错误处理**：正确使用 Swift 的错误处理系统
- **文档**：使用 Swift 文档注释记录代码
- **性能**：使用懒加载属性和值类型获得更好性能

---

## 15.11 Swift 风格检查清单

- [ ] 变量和函数使用 camelCase
- [ ] 类型使用 PascalCase
- [ ] 安全处理可选类型
- [ ] 使用 guard 语句进行早期返回
- [ ] 尽可能优先使用结构体而不是类
- [ ] 使用扩展组织代码
- [ ] 记录公共 API
- [ ] 使用适当的访问控制
- [ ] 遵循 Swift 命名约定
- [ ] 适当使用 Swift 特定功能

---

恭喜！你已经完成了 JavaScript 到 Swift 的学习路径。你现在对 Swift 开发有了坚实的基础，并理解了 JavaScript 和 Swift 之间的关键差异和相似之处。 