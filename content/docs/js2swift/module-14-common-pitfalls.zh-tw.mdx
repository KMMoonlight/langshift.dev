# 模組 14：常見陷阱

## 概述

從 JavaScript 轉向 Swift 時，開發者經常會遇到特定的陷阱和誤解。本模組識別最常見的問題並提供解決方案，幫助你避免這些陷阱。

## 學習目標

- 識別從 JavaScript 轉換到 Swift 時的常見陷阱
- 理解 Swift 的類型系統和記憶體管理
- 學習錯誤處理的最佳實踐
- 避免常見的語法和語義錯誤
- 培養 Swift 特定的思維方式

---

## 14.1 類型系統陷阱

### 14.1.1 可選類型處理

**JavaScript（有問題）**
```javascript
// JavaScript 允許 undefined/null 而不需要顯式處理
function processUser(user) {
    return user.name; // 可能是 undefined
}
```

**Swift（正確）**
```swift
// Swift 需要顯式處理可選類型
func processUser(_ user: User?) -> String? {
    return user?.name // 安全的可選鏈
}

// 或者強制解包（危險）
func processUser(_ user: User?) -> String {
    return user!.name // 如果 user 是 nil 會崩潰
}

// 最佳實踐：使用 guard 或 if let
func processUser(_ user: User?) -> String {
    guard let user = user else {
        return "未知用戶"
    }
    return user.name
}
```

### 14.1.2 類型推斷 vs 顯式類型

**JavaScript**
```javascript
// JavaScript 是動態類型
let value = 42; // number
value = "hello"; // string - 允許
```

**Swift**
```swift
// Swift 是靜態類型
var value = 42 // Int
// value = "hello" // 編譯錯誤
var value2: Any = 42
value2 = "hello" // 需要顯式的 Any 類型
```

---

## 14.2 記憶體管理問題

### 14.2.1 循環引用

**JavaScript（自動垃圾回收）**
```javascript
// JavaScript 自動處理記憶體
class Parent {
    constructor() {
        this.child = null;
    }
}

class Child {
    constructor(parent) {
        this.parent = parent; // 沒有記憶體問題
    }
}
```

**Swift（ARC）**
```swift
// Swift 需要仔細管理記憶體
class Parent {
    var child: Child?
    
    deinit {
        print("Parent 已釋放")
    }
}

class Child {
    weak var parent: Parent? // 使用 weak 避免循環引用
    
    deinit {
        print("Child 已釋放")
    }
}
```

### 14.2.2 值類型 vs 引用類型

**JavaScript（一切都是引用）**
```javascript
// JavaScript 物件總是引用
let obj1 = { name: "John" };
let obj2 = obj1;
obj2.name = "Jane";
console.log(obj1.name); // "Jane" - 都指向同一個物件
```

**Swift（預設值類型）**
```swift
// Swift 結構體是值類型
struct Person {
    var name: String
}

var person1 = Person(name: "John")
var person2 = person1
person2.name = "Jane"
print(person1.name) // "John" - 不同的副本

// 類是引用類型
class PersonClass {
    var name: String
    
    init(name: String) {
        self.name = name
    }
}

var person3 = PersonClass(name: "John")
var person4 = person3
person4.name = "Jane"
print(person3.name) // "Jane" - 同一個引用
```

---

## 14.3 錯誤處理差異

### 14.3.1 Try-Catch vs Do-Catch

**JavaScript**
```javascript
try {
    const result = riskyOperation();
    console.log(result);
} catch (error) {
    console.error("錯誤:", error.message);
}
```

**Swift**
```swift
do {
    let result = try riskyOperation()
    print(result)
} catch {
    print("錯誤: \(error)")
}

// 或者使用 try? 獲得可選結果
if let result = try? riskyOperation() {
    print(result)
}
```

### 14.3.2 錯誤傳播

**JavaScript**
```javascript
function processData() {
    try {
        return parseData();
    } catch (error) {
        throw new Error("處理失敗: " + error.message);
    }
}
```

**Swift**
```swift
func processData() throws -> String {
    do {
        return try parseData()
    } catch {
        throw ProcessingError.failed(underlying: error)
    }
}
```

---

## 14.4 集合和陣列差異

### 14.4.1 可變性

**JavaScript**
```javascript
// JavaScript 陣列總是可變的
const arr = [1, 2, 3];
arr.push(4); // 即使使用 const 也能工作
```

**Swift**
```swift
// Swift 陣列可以是不可變的
let arr = [1, 2, 3]
// arr.append(4) // 編譯錯誤

var mutableArr = [1, 2, 3]
mutableArr.append(4) // 可以工作
```

### 14.4.2 陣列方法

**JavaScript**
```javascript
// JavaScript 陣列方法
const numbers = [1, 2, 3, 4, 5];
const doubled = numbers.map(x => x * 2);
const filtered = numbers.filter(x => x > 2);
```

**Swift**
```swift
// Swift 陣列方法
let numbers = [1, 2, 3, 4, 5]
let doubled = numbers.map { $0 * 2 }
let filtered = numbers.filter { $0 > 2 }
```

---

## 14.5 函數和閉包差異

### 14.5.1 函數簽名

**JavaScript**
```javascript
// JavaScript 函數很靈活
function add(a, b) {
    return a + b;
}

add(1, 2); // 3
add("1", "2"); // "12"
```

**Swift**
```swift
// Swift 函數是類型安全的
func add(_ a: Int, _ b: Int) -> Int {
    return a + b
}

add(1, 2) // 3
// add("1", "2") // 編譯錯誤
```

### 14.5.2 閉包 vs 箭頭函數

**JavaScript**
```javascript
// JavaScript 箭頭函數
const multiply = (a, b) => a * b;
const numbers = [1, 2, 3];
const doubled = numbers.map(x => x * 2);
```

**Swift**
```swift
// Swift 閉包
let multiply: (Int, Int) -> Int = { a, b in a * b }
let numbers = [1, 2, 3]
let doubled = numbers.map { $0 * 2 }
```

---

## 14.6 常見語法錯誤

### 14.6.1 分號

**JavaScript**
```javascript
// JavaScript 分號是可選的但推薦使用
let x = 1
let y = 2;
```

**Swift**
```swift
// Swift 不使用分號（除非一行多個語句）
let x = 1
let y = 2
let z = 3; let w = 4 // 只在需要時使用
```

### 14.6.2 變數宣告

**JavaScript**
```javascript
// JavaScript 變數宣告
var oldWay = "已棄用";
let modernWay = "推薦";
const constant = "不可變";
```

**Swift**
```swift
// Swift 變數宣告
var mutable = "可以改變"
let constant = "不能改變"
```

---

## 14.7 避免陷阱的最佳實踐

### 14.7.1 始終安全處理可選類型

```swift
// ❌ 錯誤 - 強制解包
let name = user!.name

// ✅ 正確 - 安全解包
if let name = user?.name {
    print(name)
}

// ✅ 更好 - Guard 語句
guard let name = user?.name else {
    return
}
print(name)
```

### 14.7.2 使用強類型系統

```swift
// ❌ 錯誤 - 使用 Any
var data: Any = 42
data = "hello"

// ✅ 正確 - 具體類型
var number: Int = 42
var text: String = "hello"
```

### 14.7.3 正確的錯誤處理

```swift
// ❌ 錯誤 - 忽略錯誤
let _ = try? riskyOperation()

// ✅ 正確 - 適當處理錯誤
do {
    let result = try riskyOperation()
    // 使用結果
} catch {
    // 適當處理錯誤
    print("錯誤: \(error)")
}
```

---

## 14.8 練習

### 練習 1：可選類型處理
將這個 JavaScript 程式碼轉換為 Swift，並正確處理可選類型：

```javascript
function getUserName(user) {
    if (user && user.profile && user.profile.name) {
        return user.profile.name;
    }
    return "Unknown";
}
```

### 練習 2：錯誤處理
將這個 JavaScript 錯誤處理轉換為 Swift：

```javascript
function processFile(filename) {
    try {
        const content = readFile(filename);
        return parseContent(content);
    } catch (error) {
        if (error.code === 'ENOENT') {
            throw new Error('File not found');
        }
        throw error;
    }
}
```

### 練習 3：記憶體管理
識別這個 Swift 程式碼中潛在的記憶體洩漏並修復：

```swift
class ViewController {
    var dataManager: DataManager?
    
    func setup() {
        dataManager = DataManager()
        dataManager?.delegate = self
    }
}

class DataManager {
    var delegate: ViewController?
}
```

---

## 14.9 關鍵要點

- **類型安全**：Swift 的類型系統防止許多執行時錯誤
- **記憶體管理**：理解 ARC 並避免循環引用
- **可選類型**：始終安全處理可選類型
- **錯誤處理**：正確使用 Swift 的錯誤處理系統
- **值類型**：盡可能優先使用結構體而不是類
- **不可變性**：預設使用 `let`，需要時使用 `var`

---

## 14.10 常見除錯技巧

1. **使用 Xcode 除錯器**：設定斷點並檢查變數
2. **列印除錯**：使用 `print()` 和 `debugPrint()`
3. **斷言**：使用 `assert()` 和 `precondition()` 進行除錯
4. **類型檢查**：使用 `type(of:)` 在執行時檢查類型
5. **記憶體除錯**：使用 Instruments 檢測記憶體洩漏

---

在下一個模組中，我們將探索 Swift 特定的慣用法和最佳實踐，讓你的程式碼更符合 Swift 風格且更高效。 