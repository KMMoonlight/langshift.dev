# Module 14: Common Pitfalls

## Overview

When transitioning from JavaScript to Swift, developers often encounter specific pitfalls and misconceptions. This module identifies the most common issues and provides solutions to help you avoid them.

## Learning Objectives

- Identify common pitfalls when translating from JavaScript to Swift
- Understand Swift's type system and memory management
- Learn best practices for error handling
- Avoid common syntax and semantic errors
- Develop Swift-specific thinking patterns

---

## 14.1 Type System Pitfalls

### 14.1.1 Optional Handling

**JavaScript (Problematic)**
```javascript
// JavaScript allows undefined/null without explicit handling
function processUser(user) {
    return user.name; // Could be undefined
}
```

**Swift (Correct)**
```swift
// Swift requires explicit optional handling
func processUser(_ user: User?) -> String? {
    return user?.name // Safe optional chaining
}

// Or force unwrap (dangerous)
func processUser(_ user: User?) -> String {
    return user!.name // Crashes if user is nil
}

// Best practice: Use guard or if let
func processUser(_ user: User?) -> String {
    guard let user = user else {
        return "Unknown User"
    }
    return user.name
}
```

### 14.1.2 Type Inference vs Explicit Types

**JavaScript**
```javascript
// JavaScript is dynamically typed
let value = 42; // number
value = "hello"; // string - allowed
```

**Swift**
```swift
// Swift is statically typed
var value = 42 // Int
// value = "hello" // Compilation error
var value2: Any = 42
value2 = "hello" // Requires explicit Any type
```

---

## 14.2 Memory Management Issues

### 14.2.1 Reference Cycles

**JavaScript (Automatic GC)**
```javascript
// JavaScript handles memory automatically
class Parent {
    constructor() {
        this.child = null;
    }
}

class Child {
    constructor(parent) {
        this.parent = parent; // No memory issues
    }
}
```

**Swift (ARC)**
```swift
// Swift requires careful memory management
class Parent {
    var child: Child?
    
    deinit {
        print("Parent deallocated")
    }
}

class Child {
    weak var parent: Parent? // Use weak to avoid retain cycle
    
    deinit {
        print("Child deallocated")
    }
}
```

### 14.2.2 Value vs Reference Types

**JavaScript (Everything is Reference)**
```javascript
// JavaScript objects are always references
let obj1 = { name: "John" };
let obj2 = obj1;
obj2.name = "Jane";
console.log(obj1.name); // "Jane" - both point to same object
```

**Swift (Value Types by Default)**
```swift
// Swift structs are value types
struct Person {
    var name: String
}

var person1 = Person(name: "John")
var person2 = person1
person2.name = "Jane"
print(person1.name) // "John" - different copies

// Classes are reference types
class PersonClass {
    var name: String
    
    init(name: String) {
        self.name = name
    }
}

var person3 = PersonClass(name: "John")
var person4 = person3
person4.name = "Jane"
print(person3.name) // "Jane" - same reference
```

---

## 14.3 Error Handling Differences

### 14.3.1 Try-Catch vs Do-Catch

**JavaScript**
```javascript
try {
    const result = riskyOperation();
    console.log(result);
} catch (error) {
    console.error("Error:", error.message);
}
```

**Swift**
```swift
do {
    let result = try riskyOperation()
    print(result)
} catch {
    print("Error: \(error)")
}

// Or use try? for optional result
if let result = try? riskyOperation() {
    print(result)
}
```

### 14.3.2 Error Propagation

**JavaScript**
```javascript
function processData() {
    try {
        return parseData();
    } catch (error) {
        throw new Error("Processing failed: " + error.message);
    }
}
```

**Swift**
```swift
func processData() throws -> String {
    do {
        return try parseData()
    } catch {
        throw ProcessingError.failed(underlying: error)
    }
}
```

---

## 14.4 Collection and Array Differences

### 14.4.1 Mutability

**JavaScript**
```javascript
// JavaScript arrays are always mutable
const arr = [1, 2, 3];
arr.push(4); // Works even with const
```

**Swift**
```swift
// Swift arrays can be immutable
let arr = [1, 2, 3]
// arr.append(4) // Compilation error

var mutableArr = [1, 2, 3]
mutableArr.append(4) // Works
```

### 14.4.2 Array Methods

**JavaScript**
```javascript
// JavaScript array methods
const numbers = [1, 2, 3, 4, 5];
const doubled = numbers.map(x => x * 2);
const filtered = numbers.filter(x => x > 2);
```

**Swift**
```swift
// Swift array methods
let numbers = [1, 2, 3, 4, 5]
let doubled = numbers.map { $0 * 2 }
let filtered = numbers.filter { $0 > 2 }
```

---

## 14.5 Function and Closure Differences

### 14.5.1 Function Signatures

**JavaScript**
```javascript
// JavaScript functions are flexible
function add(a, b) {
    return a + b;
}

add(1, 2); // 3
add("1", "2"); // "12"
```

**Swift**
```swift
// Swift functions are type-safe
func add(_ a: Int, _ b: Int) -> Int {
    return a + b
}

add(1, 2) // 3
// add("1", "2") // Compilation error
```

### 14.5.2 Closures vs Arrow Functions

**JavaScript**
```javascript
// JavaScript arrow functions
const multiply = (a, b) => a * b;
const numbers = [1, 2, 3];
const doubled = numbers.map(x => x * 2);
```

**Swift**
```swift
// Swift closures
let multiply: (Int, Int) -> Int = { a, b in a * b }
let numbers = [1, 2, 3]
let doubled = numbers.map { $0 * 2 }
```

---

## 14.6 Common Syntax Errors

### 14.6.1 Semicolons

**JavaScript**
```javascript
// JavaScript semicolons are optional but recommended
let x = 1
let y = 2;
```

**Swift**
```swift
// Swift doesn't use semicolons (except for multiple statements on one line)
let x = 1
let y = 2
let z = 3; let w = 4 // Only when needed
```

### 14.6.2 Variable Declaration

**JavaScript**
```javascript
// JavaScript variable declarations
var oldWay = "deprecated";
let modernWay = "preferred";
const constant = "immutable";
```

**Swift**
```swift
// Swift variable declarations
var mutable = "can change"
let constant = "cannot change"
```

---

## 14.7 Best Practices to Avoid Pitfalls

### 14.7.1 Always Handle Optionals Safely

```swift
// ❌ Bad - Force unwrapping
let name = user!.name

// ✅ Good - Safe unwrapping
if let name = user?.name {
    print(name)
}

// ✅ Better - Guard statement
guard let name = user?.name else {
    return
}
print(name)
```

### 14.7.2 Use Strong Type System

```swift
// ❌ Bad - Using Any
var data: Any = 42
data = "hello"

// ✅ Good - Specific types
var number: Int = 42
var text: String = "hello"
```

### 14.7.3 Proper Error Handling

```swift
// ❌ Bad - Ignoring errors
let _ = try? riskyOperation()

// ✅ Good - Handle errors properly
do {
    let result = try riskyOperation()
    // Use result
} catch {
    // Handle error appropriately
    print("Error: \(error)")
}
```

---

## 14.8 Exercises

### Exercise 1: Optional Handling
Convert this JavaScript code to Swift with proper optional handling:

```javascript
function getUserName(user) {
    if (user && user.profile && user.profile.name) {
        return user.profile.name;
    }
    return "Unknown";
}
```

### Exercise 2: Error Handling
Convert this JavaScript error handling to Swift:

```javascript
function processFile(filename) {
    try {
        const content = readFile(filename);
        return parseContent(content);
    } catch (error) {
        if (error.code === 'ENOENT') {
            throw new Error('File not found');
        }
        throw error;
    }
}
```

### Exercise 3: Memory Management
Identify potential memory leaks in this Swift code and fix them:

```swift
class ViewController {
    var dataManager: DataManager?
    
    func setup() {
        dataManager = DataManager()
        dataManager?.delegate = self
    }
}

class DataManager {
    var delegate: ViewController?
}
```

---

## 14.9 Key Takeaways

- **Type Safety**: Swift's type system prevents many runtime errors
- **Memory Management**: Understand ARC and avoid retain cycles
- **Optionals**: Always handle optionals safely
- **Error Handling**: Use Swift's error handling system properly
- **Value Types**: Prefer structs over classes when possible
- **Immutability**: Use `let` by default, `var` when needed

---

## 14.10 Common Debugging Tips

1. **Use Xcode's Debugger**: Set breakpoints and inspect variables
2. **Print Debugging**: Use `print()` and `debugPrint()`
3. **Assertions**: Use `assert()` and `precondition()` for debugging
4. **Type Checking**: Use `type(of:)` to check types at runtime
5. **Memory Debugging**: Use Instruments to detect memory leaks

---

In the next module, we will explore Swift-specific idioms and best practices that make your code more Swift-like and efficient. 