# JavaScript to C++ Learning Module - Cursor Rules

## Module Overview
This module focuses on learning the language transition from JavaScript to C++, helping developers quickly master C++ programming through comparative teaching, with a strong emphasis on memory management, performance, and systems programming.

## Core Principles

### 1. JavaScript Perspective Teaching
- Always start from the thinking habits of JavaScript developers
- Use JavaScript concepts to explain C++ features
- Emphasize the syntax differences and conceptual mapping between the two languages
- Avoid direct translation, focus on understanding the differences in design philosophy, especially regarding memory and performance.

### 2. C++ Best Practices
- Follow modern C++ coding guidelines (e.g., C++ Core Guidelines)
- Emphasize RAII, smart pointers, and efficient resource management
- Introduce best practices from the C++ community for performance and safety

### 3. Comparative Learning Strategy
- Provide a comparison between JavaScript and C++ for each concept
- Use editor components to display runnable code examples
- Explain the design philosophy behind syntax differences, particularly for memory and execution models
- Provide a comparison of performance characteristics and usage scenarios

## Code Example Specifications

### Editor Component Usage
```mdx
<UniversalEditor title="Example Title" compare={true}>
```javascript !! js
// JavaScript code
console.log("Hello World");
```

```cpp !! cpp
// C++ code
#include <iostream>

int main() {
    std::cout << "Hello World" << std::endl;
    return 0;
}
```
</UniversalEditor>
```

### Code Comment Requirements
- Use `//` for comments in both JavaScript and C++ code
- Add detailed English explanations
- Highlight syntax differences and conceptual mapping

### Comparative Example Structure
1.  **Concept Introduction** - Explain from a JavaScript perspective
2.  **Syntax Comparison** - Show implementations in both languages side-by-side
3.  **Difference Explanation** - Explain syntax differences and design philosophy
4.  **Usage Scenarios** - Explain when to use which language feature
5.  **Performance Analysis** - Compare the performance characteristics of the two implementations

## Content Organization Rules

### Each learning module should include:
1.  **Concept Introduction** - Start with JavaScript concepts
2.  **C++ Syntax** - Show the corresponding C++ implementation
3.  **Comparative Analysis** - Explain the differences and reasons in detail
4.  **Practical Application** - Provide real-world usage scenarios
5.  **Exercises** - Reinforce learning content
6.  **Best Practices** - C++-specific coding standards

### Key Concept Comparison
- **Variable Declaration**: `let/const` vs. explicit type declaration
- **Function Definition**: `function` vs. explicit return/parameter types
- **Class Definition**: `class` (ES6) vs. `class` (C++)
- **Asynchronous Programming**: Promise/async/await vs. `std::async`/`std::future`/coroutines
- **Module System**: ES6 modules vs. C++ modules/headers/namespaces
- **Error Handling**: `try-catch` vs. `try-catch-throw` (exceptions)
- **Memory Management**: Garbage Collection vs. Manual/Smart Pointers
- **Pointers/References**: No direct equivalent vs. explicit pointers and references
- **Templates**: No direct equivalent vs. C++ templates for generic programming

## AI Assistant Behavior Guidelines

### Response Style
- Use English for responses
- Explain C++ concepts from a JavaScript perspective
- Provide specific code comparison examples
- Recommend using editor components
- Focus on C++'s performance characteristics and low-level control

### Code Generation
- Generate C++ code that conforms to modern C++ standards
- Provide the corresponding JavaScript implementation
- Include complete error handling where appropriate
- Add detailed English comments
- Wrap code in editor components
- Consider C++ performance optimizations and memory safety

### Problem Solving
- Prioritize the thinking habits of JavaScript developers
- Provide multiple C++ solutions
- Explain the reasons for choosing a specific solution, especially regarding performance and memory
- Recommend C++ best practices
- Verify the solution in the editor
- Analyze C++-specific performance bottlenecks and memory implications

## Special Instructions

### When the user asks about a C++ concept:
1.  First, explain the corresponding JavaScript concept or how JavaScript handles it.
2.  Show the C++ syntax and usage.
3.  Provide a comparative example (using the editor component).
4.  Explain usage scenarios and precautions, particularly for memory management and performance.
5.  Analyze C++'s performance characteristics and its advantages/disadvantages compared to JavaScript.

### When the user needs a code example:
1.  Wrap the code in an editor component.
2.  Provide complete, runnable code.
3.  Include a comparative implementation of JavaScript and C++.
4.  Add detailed English comments.
5.  Explain how the code works, focusing on C++'s unique aspects.
6.  Provide C++ performance optimization and memory safety suggestions.

### When the user encounters a problem:
1.  Analyze the root cause of the problem.
2.  Provide multiple C++ solutions.
3.  Explain the pros and cons of each solution, with a focus on performance, memory, and safety.
4.  Recommend C++ best practices.
5.  Verify the solution in the editor.
6.  Consider C++-specific performance impacts and memory implications.

## Quality Assurance

### Code Quality
- All C++ code must comply with modern C++ standards and best practices.
- Verify with static analysis tools (e.g., Clang-Tidy, cppcheck).
- Include appropriate test cases.
- Follow C++ best practices for memory safety and performance.
- Test execution in the editor.
- Performance monitoring and optimization.

### Document Quality
- Content is accurate.
- Example code is complete and runnable.
- Links and references are correct.
- Formatting is standardized and consistent.
- Interactive code examples are usable.
- Multilingual content is synchronized.

### User Experience
- Clear learning path.
- Easy-to-understand example code.
- Appropriate difficulty for exercises.
- Provide sufficient context.
- Fast response from the code editor.
- Performance optimization experience.

## Module-Specific Specifications

### C++-Specific Concepts
- **Pointers and References**: Direct memory manipulation.
- **Smart Pointers**: `unique_ptr`, `shared_ptr`, `weak_ptr` for automatic memory management.
- **Templates**: Generic programming and compile-time polymorphism.
- **RAII**: Resource Acquisition Is Initialization idiom.
- **Move Semantics**: Efficient resource transfer.
- **Concurrency Primitives**: Mutexes, condition variables, atomics.

### Performance Optimization Focus
- **Memory Management**: Manual control vs. garbage collection.
- **Execution Model**: Compiled native code vs. JIT compilation.
- **Concurrency Programming**: True parallelism vs. event loop.
- **Data Structures**: STL containers and their performance characteristics.

### Ecosystem Comparison
- **Package Management**: Conan, vcpkg vs. npm.
- **Build Tools**: CMake, Make vs. webpack.
- **Testing Frameworks**: Catch2, Google Test vs. Jest.

---

Remember: The core goal of this module is to help JavaScript developers quickly master C++. Therefore, all explanations and examples should be from a JavaScript perspective, and fully utilize editor components to provide an interactive learning experience. At the same time, pay attention to C++-specific best practices, performance characteristics, and memory safety.